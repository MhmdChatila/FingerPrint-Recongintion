# -*- coding: utf-8 -*-
"""FinalProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BGk8Q055J8mJSjJOUOvLWJPHjCttfEhT
"""

# gaussian blur with kernel size 7 and variance 0
def gauss(img):
  smoothedImage = cv2.GaussianBlur(img,(7,7), 0)
  return smoothedImage

# displaying histogram to check how adaptive histogram equalization affects image's histogram
def displayHistogram(img, title):
  hist = cv2.calcHist([img], [0], None, [256], [0, 256])
  plt.figure()
  plt.title(title)
  plt.xlabel("Pixel Value")
  plt.ylabel("# of Pixels")
  plt.plot(hist)
  plt.xlim([0, 256])

# adaptive histogram equalization to improve contrast through stretching out intensity range
def adaptiveHistogramEqualization(img):
  clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
  equalizedImage = clahe.apply(img)
  return equalizedImage

# binarization through adaptive thresholding where threshold is mean of neighborhood and median blur for removing pepper after binarization
def binarization(img):
  binaryImage = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,3,5)
  binaryImage = cv2.medianBlur(binaryImage,3)
  return binaryImage

# thinning image through transforming binary image into a skeletized form using the technique of Zhang-Suen
def thinning(img):
  thinnedImage = cv2.ximgproc.thinning(invert(img))
  data = np.array(thinnedImage)
  row, col = data.shape
  for i in range(0, row):
    for j in range(0, col):
      if(data[i, j] == 255):
        data[i, j] = 0
      else:
        data[i, j] = 255
  thinnedImage = Image.fromarray(data)
  return thinnedImage

# drawing ellipses on minutiae points
def drawing(y, x, img):
  draw = ImageDraw.Draw(img)
  ellipseSize = 2
  draw.ellipse([(x - ellipseSize, y - ellipseSize), (x + ellipseSize, y + ellipseSize)])

# extracting minutiae points from given image and returning them in a dictionary of lists
def extraction(img):
  image2 = img_as_float(img)
  row, col = image2.shape
  features = {"bifurcation":[],"ending":[]}
  arrFeatures = []
  cn1 = 0
  cn3 = 0
  for i in range(1, row - 1):
    for j in range(1, col - 1):
      minutiaeType = computation(image2, i, j)
      if minutiaeType == "ending":
        cn1 += 1
        features[minutiaeType].append((i,j))
        arrFeatures.append((i, j))
        drawing(i, j, img)
      elif minutiaeType == "bifurcation":
        cn3 += 1
        features[minutiaeType].append((i,j))
        arrFeatures.append((i, j))
        drawing(i, j, img)
  return img, cn1, cn3, features, arrFeatures

# computing crossing number to figure out what kind of ridge point said pixel is
def computation(img, i, j):
  cells = [(-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]
  if(int(img[i][j]) == 0):
    p = [int(img[i + k][j + l]) for k, l in cells]
    cn = 0
    for k in range(0, 8):
      cn += abs(int(p[k]) - int(p[k + 1]))
    cn *= 0.5
    if cn == 1.0:
      return "ending"
    elif cn == 3.0:
      return "bifurcation"
  return "none"

# euclidean distance formula
def calculateDistance(i1, j1, i2, j2):
  return np.sqrt(pow((i1-i2), 2) + pow((j1-j2), 2))

# matching 2 images' minutiae points to figure out if the fingerprints belong to the same person
def matchingScore(featuresA, featuresB, tolerance=10):
  countMatching= 0
  if(len(featuresA) < len(featuresB)):
    size = len(featuresA)
  else:
    size = len(featuresB)
  avgMinutiae = (len(featuresA) + len(featuresB))/2
  for k in range(0, size):
    spatialDistance = calculateDistance(featuresA[k][0], featuresA[k][1], featuresB[k][0], featuresB[k][1])
    if(spatialDistance <= tolerance):
      countMatching +=1
  matchingPerc = countMatching/avgMinutiae*100
  return matchingPerc

import cv2 # main library
from matplotlib import pyplot as plt # to plot histograms
from google.colab.patches import cv2_imshow # to display images in google colab
import numpy as np # to convert images to matrices
from skimage.util import invert # to invert image before thinning
from PIL import Image, ImageDraw # to draw ellipses on image
from skimage import img_as_float # to convert image to array of floats

# creating a dataset of 5 fingerprints
datasetOriginalFingerprints = ['1_2.TIF', '1_3.TIF', '1_4.TIF', '1_5.TIF', '1_6.TIF']
namesOfOwners = ['Mohammad', 'Khaled', 'Salwa', 'Hammoud', 'Chatila']
datasetProcessedFingerprints = {'1_2.TIF':[], '1_3.TIF':[], '1_4.TIF':[], '1_5.TIF':[], '1_6.TIF':[]}

for data in datasetOriginalFingerprints:
  originalImage = cv2.imread(data)
  grayImage = cv2.cvtColor(originalImage, cv2.COLOR_BGR2GRAY)
  blurredImage = gauss(grayImage)
  equalizedImage = adaptiveHistogramEqualization(blurredImage)
  binaryImage = binarization(equalizedImage)
  skeletonImage = thinning(binaryImage)
  processedImage, CN1, CN3, features, arrOfFeatures = extraction(skeletonImage)
  datasetProcessedFingerprints[data].append((processedImage, CN1, CN3, features, arrOfFeatures))

'''
datasetProcessedFingerprints['1_2.TIF'][0][0] has the image, 
datasetProcessedFingerprints['1_2.TIF'][0][1] has the number of minutiae points with cn=1
datasetProcessedFingerprints['1_2.TIF'][0][2] has the number of minutiae points with cn=3
datasetProcessedFingerprints['1_2.TIF'][0][3] has a dictionary that contains location of ridge endings and bifurcations
datasetProcessedFingerprints['1_2.TIF'][0][4] has an array of all minutiae points (endings and bifurcations)
'''

# processing testing fingerprint
testingImage = cv2.imread('1_4.TIF')
print("Original Fingerprint:")
cv2_imshow(testingImage)

grayImage = cv2.cvtColor(testingImage, cv2.COLOR_BGR2GRAY)
print("Grayscale Fingerprint:")
cv2_imshow(grayImage)

blurredImage = gauss(grayImage)
equalizedImage = adaptiveHistogramEqualization(blurredImage)
binaryImage = binarization(equalizedImage)
skeletonImage = thinning(binaryImage)
print("Preprocessed Fingerprint:")
display(skeletonImage)

processedImage, CN1, CN3, features, arrOfFeatures = extraction(skeletonImage)
print("Processed Fingerprint:")
display(processedImage)

# comparing testing fingerprint to dataset
counter = 0
for data in datasetOriginalFingerprints:
  arrayOfDatasetImage = datasetProcessedFingerprints[data][0][4]
  score = matchingScore(arrOfFeatures, arrayOfDatasetImage)
  if(score == 100):
    print("\nThe input fingerprint belongs to:", namesOfOwners[counter]) 
    print("File name:", data)
    break
  counter += 1


print("\n\nChange in histogram is shown clearly in the histograms below:")
displayHistogram(blurredImage, "Before Equalization")
displayHistogram(equalizedImage, "After Equalization")